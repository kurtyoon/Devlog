---
title: "Docker 속으로 2편 - UFS"
published: 2025-03-26
description: Docker 속으로 2편 - UFS
tags: [Docker]
category: DevOps
author: kurtyoon
thumbnail: https://i.esdrop.com/d/f/hhaNifrpr0/JYBuZN8W0M.png # 배너 이미지
draft: true
---

Docker를 사용하다 보면 문득 Docker는 어떻게 파일을 관리할까 라는 생각이 든다. 결론부터 말하자면 Docker는 **Union File System(UFS)** 을 사용한다.

**Union**은 사전적으로 '연합', '결함' 이라는 의미를 가지고 있다. 따라서, **UFS**는 File System의 결합, 연합 정도로 생각할 수 있다. 즉, 여러 개의 File System을 하나로 결합하여 하나의 File System처럼 취급할 수 있도록 해주는 것이다.

Docker에서 Image와 Container의 차이는 명확하다. 보통 이를 리눅스의 프로세스 모델과 비교하여 설명하곤 한다. 리눅스에서의 Process를 Docker Container라고 한다면, Docker Image는 프로그램 Binary라고 생각할 수 있다.

프로세스를 여러 번 실행하더라도 프로그램 바이너리는 변경되지 않는다. 즉, 프로세스가 실행 중에 내부에서 어떤 작업을 하더라도 바이너리 자체가 변경되는 일은 없다. 또한, 여러 개의 프로세스가 하나의 바이너리를 이용해 실행될 수 있다.

이러한 개념은 도커의 이미지와 컨테이너에도 적용된다. 도커 이미지를 이용해 여러 컨테이너를 실행할 수 있지만, 이미지 자체는 변경되지 않는다.

컨테이너를 이용해 우분투를 실행했다고 가정해보자. 컨테이너 내부에서 사용자는 마치 독립적인 우분투와 파일 시스템을 소유한 것처럼 자유롭게 사용할 수 있다. 신규 파일이나 디렉토리를 생성하거나, 기존에 존재하던 객체들을 변경할 수도 있다.

그러나, 컨테이너를 실행하는 데 사용된 이미지는 변경되지 않는다. 그렇다면, 컨테이너 내에서 변경한 내용들은 어디에 저장되는 것일까?

그 비밀은 **UFS**에 존재한다.

---

### UFS (Union File System)

![](https://kurtyoon-space.s3.ap-northeast-2.amazonaws.com/UFS.png)

우리가 컨테이너 내부에서 보는 파일 시스템은 사실 UFS를 통해 조합된 파일 시스템이다.

이 파일 시스템에는 어떤 구성의 파일 시스템이 있든 간에, UFS는 이를 하나의 통합된 파일 시스템으로 보여준다. 사용자는 마치 독립적으로 파일 시스템을 사용하는 것 처럼 느낄 뿐이다.

실제로, 컨테이너 내부의 파일 시스템은 여러 개의 파일 시스템이 겹쳐져 있는 구조이다.

컨테이너는 이미지를 이용해 실행된다. 하지만, 해당 이미지는 반드시 하나의 이미지 레이어로만 구성되어있지 않을 수 있다. 예를 들어, 사용자가 우분투라는 베이스 이미지를 이용해 컨테이너를 실행한 뒤, 내부에서 Nginx 같은 프로그램을 추가로 설치했다고 가정해보자.

이 상태에서 컨테이너를 중지하고 삭제하면, 설치했던 어플리케이션은 함께 삭제되어 재사용할 수 없게된다.

이를 방지하기 위해서는 사용자는 이러한 변경 상태를 이미지 형태로 저장해 둘 수 있다.

#### Image Layer와 Writable Layer

이처럼, 도커는 이미지 위에 변경 사항을 추가하고, 이를 또 다른 이미지로 저장하는 과정을 반복한다.

도커는 이러한 변경 사항을 이미지 레이어라는 개념으로 관리하며, 변경된 내용을 하나 하나 순차적으로 저장한다. 사용자는 도커가 원하는 레이어까지 합쳐진 결과를 보여주기 때문에, 이를 단일 파일 시스템처럼 사용할 수 있다.

특정 이미지를 이용해 컨테이너를 실행하면, 여러 이미지 레이어(Read-Only Layer)가 하단에 쌓이고, 그 위에 컨테이너 레이어(Writable Layer)가 추가된다. 이러한 레이어들은 결합되어 사용자에게 하나의 통합된 파일 시스템으로 제공된다.

도커는 다음과 같은 구조로 레이어를 관리한다.

1. Read-Only Image Layer: 변경되지 않는 레이어로, 베이스 이미지나 중간에 저장된 변경 사항들을 포함한다.
2. Writable Layer: 컨테이너 실행 시 생성되는 레이어로, 사용자 변경 사항이 저장된다.

이러한 구조 덕분에 사용자가 변경하는 사항은 하단의 Read-Only Layer를 변경하지 않고, 최상단의 Writable Layer에만 저장된다. 따라서, 이미지는 변경되지 않고 그대로 유지된다.

단, Writable Layer는 컨테이너가 삭제되면 함께 사라지게 된다.

![](https://kurtyoon-space.s3.ap-northeast-2.amazonaws.com/Container+and+Layer.webp)

변경 사항을 지속적으로 유지하기 위해서는 어떻게 해야할까?

컨테이너 내부의 변경 사항을 영구적으로 저장하기 위해서는 두 가지 방법을 사용할 수 있다.

첫번째는, 컨테이너 변경 내용을 새로운 이미지로 저장하는 방법이다. 컨테이너에서 변경이 발생한 후, 이를 이미지로 커밋하여 저장한다. 하지만, 관리적인 측면에서는 이미지의 변경은 최소화하는 것이 좋다. 변경이 자주 발생하는 경우 이미지 관리가 복잡해질 수 있다.

두 번째는, Volume을 구성하여 데이터를 저장할 수 있다. 변경 사항을 컨테이너 외부의 볼륨에 저장한다. 이때, 볼륨은 컨테이너가 삭제되더라도 데이터가 유지되므로 효율적으로 관리할 수 있다.
